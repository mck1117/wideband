/**
 * @file	tunerstudio_io.h
 * @file TS protocol commands and methods are here
 *
 * @date Mar 8, 2015
 * @author Andrey Belomutskiy, (c) 2012-2020
 */

#pragma once

/* to get ChibiOS hal config options */
#include "hal.h"

#include "tunerstudio_impl.h"

/* TODO: find better place */
#define BLOCKING_FACTOR 256

/* TODO: From autogenerated, rework! */
#define TS_BURN_COMMAND 'B'
#define TS_BURN_COMMAND_char B
#define TS_CHUNK_WRITE_COMMAND 'C'
#define TS_CHUNK_WRITE_COMMAND_char C
#define ts_command_e_TS_BENCH_CATEGORY 22
#define ts_command_e_TS_CLEAR_WARNINGS 17
#define ts_command_e_TS_COMMAND_1 1
#define ts_command_e_TS_COMMAND_11 11
#define ts_command_e_TS_COMMAND_12 12
#define ts_command_e_TS_COMMAND_13 13
#define ts_command_e_TS_COMMAND_14 14
#define ts_command_e_TS_COMMAND_15 15
#define ts_command_e_TS_COMMAND_16 16
#define ts_command_e_TS_COMMAND_4 4
#define ts_command_e_TS_COMMAND_5 5
#define ts_command_e_TS_COMMAND_9 9
#define ts_command_e_TS_CRAZY 32
#define ts_command_e_TS_DEBUG_MODE 0
#define ts_command_e_TS_GRAB_PEDAL_UP 6
#define ts_command_e_TS_GRAB_PEDAL_WOT 7
#define ts_command_e_TS_GRAB_TPS_CLOSED 2
#define ts_command_e_TS_GRAB_TPS_WOT 3
#define ts_command_e_TS_IGNITION_CATEGORY 18
#define ts_command_e_TS_INJECTOR_CATEGORY 19
#define ts_command_e_TS_RESET_TLE8888 8
#define ts_command_e_TS_UNUSED_23 23
#define ts_command_e_TS_UNUSED_25 25
#define ts_command_e_TS_UNUSED_26 26
#define ts_command_e_TS_UNUSED_27 27
#define ts_command_e_TS_UNUSED_28 28
#define ts_command_e_TS_UNUSED_29 29
#define ts_command_e_TS_UNUSED_30 30
#define ts_command_e_TS_UNUSED_31 31
#define ts_command_e_TS_UNUSED_CJ125_CALIB 24
#define ts_command_e_TS_WIDEBAND 21
#define ts_command_e_TS_WRITE_FLASH 10
#define ts_command_e_TS_X14 20
#define TS_COMMAND_F 'F'
#define TS_COMMAND_F_char F
#define TS_COMPOSITE_DISABLE 2
#define TS_COMPOSITE_ENABLE 1
#define TS_CRC_CHECK_COMMAND 'k'
#define TS_CRC_CHECK_COMMAND_char k
#define TS_FILE_VERSION 20210312
#define TS_GET_CONFIG_ERROR 'e'
#define TS_GET_CONFIG_ERROR_char e
#define TS_GET_FIRMWARE_VERSION 'V'
#define TS_GET_FIRMWARE_VERSION_char V
#define TS_GET_LOGGER_GET_BUFFER 'L'
#define TS_GET_LOGGER_GET_BUFFER_char L
#define TS_GET_OUTPUTS_SIZE '4'
#define TS_GET_OUTPUTS_SIZE_char 4
#define TS_HELLO_COMMAND 'S'
#define TS_HELLO_COMMAND_char S
#define TS_ONLINE_PROTOCOL 'z'
#define TS_ONLINE_PROTOCOL_char z
#define TS_OUTPUT_COMMAND 'O'
#define TS_OUTPUT_COMMAND_char O
#define TS_PAGE_COMMAND 'P'
#define TS_PAGE_COMMAND_char P
#define TS_PROTOCOL "001"
#define TS_QUERY_COMMAND 'Q'
#define TS_QUERY_COMMAND_char Q
#define TS_READ_COMMAND 'R'
#define TS_READ_COMMAND_char R
#define TS_RESPONSE_BURN_OK 4
#define TS_RESPONSE_COMMAND_OK 7
#define TS_RESPONSE_CRC_FAILURE 0x82
#define TS_RESPONSE_FRAMING_ERROR 0x8D
#define TS_RESPONSE_OK 0
#define TS_RESPONSE_OUT_OF_RANGE 0x84
#define TS_RESPONSE_UNDERRUN 0x80
#define TS_RESPONSE_UNRECOGNIZED_COMMAND 0x83
#define TS_TEST_COMMAND 't'
#define TS_TEST_COMMAND_char t

class TsChannelBase {
public:
	TsChannelBase(const char *name);
	// Virtual functions - implement these for your underlying transport
	virtual void write(const uint8_t* buffer, size_t size, bool isEndOfPacket = false) = 0;
	virtual size_t readTimeout(uint8_t* buffer, size_t size, int timeout) = 0;

	// These functions are optional to implement, not all channels need them
	virtual void flush() { }
	virtual bool isConfigured() const { return true; }
	virtual bool isReady() const { return true; }
	virtual void stop() { }

	// Base functions that use the above virtual implementation
	size_t read(uint8_t* buffer, size_t size);

#ifdef EFI_CAN_SERIAL
	virtual	// CAN device needs this function to be virtual for small-packet optimization
#endif
	void writeCrcPacket(uint8_t responseCode, const uint8_t* buf, size_t size, bool allowLongPackets = false);
	void sendResponse(ts_response_format_e mode, const uint8_t * buffer, int size, bool allowLongPackets = false);

	/**
	 * See 'blockingFactor' in rusefi.ini
	 */
	char scratchBuffer[BLOCKING_FACTOR + 30];
	const char *name;

	void assertPacketSize(size_t size, bool allowLongPackets);
	void crcAndWriteBuffer(uint8_t responseCode, size_t size);
	void copyAndWriteSmallCrcPacket(uint8_t responseCode, const uint8_t* buf, size_t size);

private:
	void writeCrcPacketLarge(uint8_t responseCode, const uint8_t* buf, size_t size);
};

// This class represents a channel for a physical async serial poart
class SerialTsChannelBase : public TsChannelBase {
public:
	SerialTsChannelBase(const char *name) : TsChannelBase(name) {};
	// Open the serial port with the specified baud rate
	virtual int start(uint32_t baud) = 0;
};

#if HAL_USE_SERIAL
// This class implements a ChibiOS Serial Driver
class SerialTsChannel : public SerialTsChannelBase {
public:
	SerialTsChannel(SerialDriver& driver) : SerialTsChannelBase("Serial"), m_driver(&driver) { }

	int start(uint32_t baud) override;
	void stop() override;

	void write(const uint8_t* buffer, size_t size, bool isEndOfPacket) override;
	size_t readTimeout(uint8_t* buffer, size_t size, int timeout) override;

private:
	int bt_read_line(char *str, size_t max_len);
	int bt_wait_ok(void);
	int bt_disconnect(void);

	SerialDriver* const m_driver;
};
#endif // HAL_USE_SERIAL

#if HAL_USE_UART
// This class implements a ChibiOS UART Driver
class UartTsChannel : public SerialTsChannelBase {
public:
	UartTsChannel(UARTDriver& driver) : SerialTsChannelBase("UART"), m_driver(&driver) { }

	int start(uint32_t baud) override;
	void stop() override;

	void write(const uint8_t* buffer, size_t size, bool isEndOfPacket) override;
	size_t readTimeout(uint8_t* buffer, size_t size, int timeout) override;

protected:
	UARTDriver* const m_driver;
	UARTConfig m_config;
};
#endif // HAL_USE_UART

#define CRC_VALUE_SIZE 4
// todo: double-check this
#define CRC_WRAPPING_SIZE (CRC_VALUE_SIZE + 3)

// that's 1 second
#define BINARY_IO_TIMEOUT TIME_MS2I(1000)

// that's 1 second
#define SR5_READ_TIMEOUT TIME_MS2I(1000)
